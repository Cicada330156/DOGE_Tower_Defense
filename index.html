<doctype html>
<head>
    	<title>Doge castle defense</title> 
	<style>
		body{
			margin: 0;
		}
		canvas{
			display: block;
			margin-left: auto;
			margin-right: auto;
		}
	</style>
</head>
<body>
	<canvas id="gamePanel"></canvas>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
	<script type="text/javascript">
		const canvas = document.getElementById('gamePanel');
		const app = new PIXI.Application({
			view: canvas,
			width: window.innerWidth * 0.9,
			height: window.innerHeight * 0.9,
			backgroundColor: 0x7cfc00,
			autostart: false
		});

		const thiefCate = PIXI.Texture.from('https://cdn.discordapp.com/emojis/569160672739590174.png?v=1');
		defaultWave = {
		cateSpeed: 1,
		cateSpawnRate: 120
		}
		waveType = defaultWave;
		let cates = [];
		function cateSpawn(type) {
			for (i = 0; i < 1; i++) {
				let cate = new PIXI.Sprite(thiefCate); 
				cate.currentSegment = 0;
				cate.attack = 5;
				cate.HP = 10;
				app.stage.addChild(cate);
				cates.push(cate);
			}
		}
		
		const closeDefDoge = PIXI.Texture.from('https://cdn.discordapp.com/emojis/688470220867764228.png?v=1');
		dogeCloseDef = {
		range: 20,
		attack: 5
		};
		//dogeType = dogeCloseDef;
		let doges = [];
		function dogeSpawn (dogeType) {
			let doge = new PIXI.Sprite(closeDefDoge);
			doge.range = dogeType.range;
			doge.attack = dogeType.attack;
			app.stage.addChild(doge);
			doges.push(doge);
		}
		dogeSpawn(dogeCloseDef);

		function getDistance(p1, p2) {
			xL = p1.x - p2.x;
			yL = p1.y - p2.y;
			d = Math.sqrt((xL * xL) + (yL * yL));
			return(d);
		}

		const defaultBaseHP = 20;
		baseHP = defaultBaseHP;
		function hurtBase(attacker) {
			baseHP -= attacker.attack;
			console.log("oh no! an enemy got in! \n your base's hp is now " + baseHP);
			if (baseHP <= 0) {
				app.ticker.stop();
				alert("oh noes! looks like your base was defeated by the cates!");
			}
		}

		const catePath = [[100, 100], [200, 200], [300, 200]];
		function followPath (p1, p2, attackerId, dt) {
			var right;
			var left;
			if (p1 == p2) {
				attackerId.currentSegment++;
				return;
			} else if (p1[0] == p2[0]) {
				//horizontal
				if (p1[0] > p2[0]) {
					right = false;
					attackerId.x += cateSpeed;
				} else {
					right = true;
					attackerId.x -= cateSpeed;
				}
			} else if (p1[1] == p2[1]) {
				//vertical
				if (p1[1] > p2[1]) {
					up = false;
					attackerId.x += cateSpeed;
				} else {
					up = true;
					attackerId.x -= cateSpeed;
				}
			} else {
				//diagonal
				if (p1[0] > p2[0]) {
					right = false;
				} else {
					right = true;
				}
				if (p1[1] > p2[1]) {
					up = false;
				} else {
					up = true;
				}
			}
		}	

		frame = 0;
		app.ticker.add(animate);
		function animate() {
			if (frame % waveType.cateSpawnRate == 0) {
				cateSpawn();
			}
			for (var i = 0; i < cates.length; i++) {
				cates[i].x += waveType.cateSpeed;
			}
			if (frame % 30 == 0) {
				for (var i = 0; i < doges.length; i++) {
					for (var g = 0; g < cates.length; g++) {
						spriteDistance = getDistance(cates[g].position, doges[i].position)
						if (spriteDistance <= doges[i].range) {
							console.log("bonk!");
							cates[g].HP -= doges[i].attack;
						}
						if (cates[g].HP <= 0) {
							app.stage.removeChild(cates[i]);
							cates.splice(i, 1);
						}
					}
				}
			}

			//everything after this has to be done last, for order of operations and such. otherwise it gets super buggy.
			for (var i = 0; i < cates.length - 1; i++) {
				if (cates[i].x >= app.renderer.width/2) {
					hurtBase(cates[i]);
					app.stage.removeChild(cates[i]);
					cates.splice(i, 1);
				}
			}
			frame++;
		}
		app.ticker.start();
	</script>
</body>
