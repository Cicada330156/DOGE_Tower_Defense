<doctype html>
<head>
    	<title>Doge castle defense</title> 
	<style>
		body{
			margin: 0;
		}
		canvas{
			display: block;
			margin-left: auto;
			margin-right: auto;
		}
	</style>
</head>
<body>
	<canvas id="gamePanel"></canvas>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
	<script type="text/javascript">
		const canvas = document.getElementById('gamePanel');
		const app = new PIXI.Application({
			view: canvas,
			width: window.innerWidth * 0.9,
			height: window.innerHeight * 0.9,
			backgroundColor: 0x7cfc00,
			autostart: false
		});

		const thiefCate = PIXI.Texture.from('https://cdn.discordapp.com/emojis/569160672739590174.png?v=1');
		defaultWave = {
		cateSpeed: 1,
		cateSpawnRate: 120
		}
		cateTypes = [
			{size: [113, 100], attack: 5, HP: 10},//normal cate
			{size: [113, 100]}
		]
		waveType = defaultWave;
		let cates = [];
		function cateSpawn(type, pos) {
			for (i = 0; i < 1; i++) {
				let cate = new PIXI.Sprite(thiefCate); 
				cate.anchor.set(0.5);
				cate.currentSegment = 0;
				//variables base on inputs
				cate.x = pos[0];
				cate.y = pos[1];
				//type defined traits vv
				cate.attack = cateTypes[type].attack;
				cate.HP = cateTypes[type].HP;
				cate.width = cateTypes[type].size[0];
				cate.height = cateTypes[type].size[1];
				//add to stage and array
				app.stage.addChild(cate);
				cates.push(cate);
			}
		}
		
		const closeDefDoge = PIXI.Texture.from('https://cdn.discordapp.com/emojis/688470220867764228.png?v=1');
		dogeTypes = [
		{range: 50, attack: 5}, //close defense baguette doge
		{range: 200, attach: 3} //ranged attack doge
		];
		//dogeType = dogeCloseDef;
		let doges = [];
		function dogeSpawn (type, pos) {
			for (i = 0; i < 1; i++) {
				let doge = new PIXI.Sprite(closeDefDoge);
				doge.range = dogeTypes[type].range;
				doge.attack = dogeTypes[type].attack;
				doge.anchor.set(0.5);
				doge.height = 100;
				doge.width = 100;
				doge.x = pos[0];
				doge.y = pos[1];
				app.stage.addChild(doge);
				doges.push(doge);
			}
		}
		dogeSpawn(0, [50, 35]);
		dogeSpawn(0, [50, 200]);
		dogeSpawn(0, [400, 225]);

		function getDistance(p1, p2) {
			xL = p1.x - p2.x;
			yL = p1.y - p2.y;
			d = Math.sqrt((xL * xL) + (yL * yL));
			return(d);
		}

		const defaultBaseHP = 20;
		baseHP = defaultBaseHP;
		function hurtBase(attacker) {
			baseHP -= attacker.attack;
			if (baseHP <= 0) {
				app.ticker.stop();
				alert("oh noes! looks like your base was defeated by the cates!");
			}
		}

		
		const buttonTexture = PIXI.Texture.from("https://cicada330156.github.io/DOGE_bloons/openMenuButton.png");
		console.log(buttonTexture);
		let menuOpenButton = new PIXI.Sprite(buttonTexture);
		//menuOpenButton.anchor = [1, 0];
		menuOpenButton.scale = (0.5, 0.5);
		menuOpenButton.x = 200;
		menuOpenButton.y = 200;
		console.log(menuOpenButton.position);
		app.stage.addChild(menuOpenButton);
		function openMenu () {
			
		}

		function checkVertical (p1, p2) {
			if (p1 != p2) {
				if (p1[0] != p2[0])
					if (p1[1] != p2[1])
						return(diagonal);
					}
					return(horizontal);
				}
				return(vertical);
			}
			return(no_movement);
		}

		const catePath = [[100, 100], [200, 200], [300, 200]];
		function followPath (attackerId) {
			
		}	

		frame = 0;
		app.ticker.add(animate);
		function animate() {
			if (frame % waveType.cateSpawnRate == 0) {
				if((frame / waveType.cateSpawnRate) % 2 == 0){
				cateSpawn(0, [50, 75]);
				}else{
				cateSpawn(0, [50, 250]);
				}
			}
			for (var i = 0; i < cates.length; i++) {
				//cates[i].x += waveType.cateSpeed;

			}
			if (frame % 30 == 0) {
				for (var i = 0; i < doges.length; i++) {
					for (var g = 0; g < cates.length; g++) {
						spriteDistance = getDistance(cates[g].position, doges[i].position)
						if (spriteDistance <= doges[i].range) {
							console.log("bonk!");
							cates[g].HP -= doges[i].attack;
						}
						if (cates[g].HP <= 0) {
							app.stage.removeChild(cates[g]);
							cates.splice(g, 1);
						}
					}
				}
			}

			//everything after this has to be done last, for order of operations and such. otherwise it gets super buggy.
			for (var i = 0; i < cates.length - 1; i++) {
				if (cates[i].x >= app.renderer.width) {
					hurtBase(cates[i]);
					console.log("a cate got in! \nbase HP is now " + baseHP)
					app.stage.removeChild(cates[i]);
					cates.splice(i, 1);
					i--;
				}
			}
			frame++;
		}
		app.ticker.start();
	</script>
</body>
